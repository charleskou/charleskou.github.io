{"pages":[],"posts":[{"title":"书籍","text":"分类 作者 图片 简介 链接 《错位》 《影响力》 《明朝那些事儿》","link":"/2020/02/25/books/"},{"title":"音乐","text":"按年份 2018 体面 于文文最美的期待 周笔畅That Girl Olly Murs倒数 邓紫棋广东爱情故事 广东雨神醉赤壁 林俊杰说散就散 袁维娅不染 简弘亦盗将行 马玉阳光年之外 邓紫棋往后余生 马良病变 鞠文娴年少有为 李荣浩一百万个可能 Christine Welch请先说你好 贺一航离人愁 李袁杰走马 陈一发儿东西 林俊呈一曲相思 半阳小半 陈粒西安人的歌 范炜与程渤智风筝误 刘珂矣红昭愿 音阙诗听春风吹 阿冷怀念青春 刘刚 按歌手 按类别 轻音乐 舒缓 睡眠 解压","link":"/2020/02/25/music/"},{"title":"study","text":"知识结构1. 互联网Java 数据库 MySQL Redis Elsaticsearch MQ 基础 Git 架构 K8S 版本号 GA: General Availability（正式发布的版本） 在国外都是用GA来说明release版本的 RC版：是 Release Candidate 的缩写，意思是发布倒计时，候选版本，处于Gamma阶段，该版本已经完成全部 功能并清除大部分的 BUG。到了这个阶段只会除BUG，不会对软件做任何大的更改。 从 Alpha到Beta再到Gamma是改进的先后关系，但RC1、RC2往往是取舍关系。 Final：正式版。 电商行业 互联网行业 2. 理财基金 股票 债券 3. 历史时间，地点，人物，事件，背景，影响 编年史 大事记 专题史 中国 世界 +互联网 = 互联网发展史 ​ 互联网巨头发展史 +互联网金融 +地理 +物理 +生物 +科技 +经济 名人传记 4. 通识学科知识 学习方法 商业 经济学 心理学 数学 统计 地理 物理 化学 文学 - 语言 中文，英文， 文言文，诗词 政治 - 言论 世界观，人生观，价值观 哲学 ​ 思想 - 错位竞争 ​ 名言警句 5. 生活消费：衣、食、住、行，娱乐 - 音乐，影视，游戏，电子产品 买房 房价 物业 水电 装修 母婴，育儿，教育，奶粉，米粉，尿不湿 医药保健，健身 保险 日用精品 +互联网 购买 = 网购 旅游， + 地理 饮食 + 地理","link":"/2019/08/09/study/"},{"title":"互联网大事记","text":"序言这是一个网络互联时代，这是一个网络经济时代，网络带来的微小而持续的变化改变了自工业时代以来的每一个人的行为方式，从而产生了新的经济发展模式。互联网不仅仅是将各种计算设备连到一起为人类提供了一种新的通信手段，而是从文化、经济和政治等方面根本地改变了我们的社会，并且带动了世界文明的进步。 如今，我们的学习、工作和生活的方方面面都离不开互联网。有了互联网，我们可以尽情在知识的海洋中遨游;有了互联网，我们可以轻松在琳琅满目的商店中穿梭;有了互联网，我们可以结交到素未谋面的志趣相投的朋友。 互联网如此之大，以至于它不是一个人、一个研究机构或公司，甚至不是一个国家的发明，而是整个世界共同贡献的结果。 互联网就像吃饭和睡觉一样，成为了必需品 最近30年互联网行业发展纪要，时间线 1998 - 2008 - 2018 - 2028 年份 - 概要 - 行业专题 每年要点： 时代背景 经济趋势 网络状况 电脑市场 手机市场 成立的公司 上市的公司 巨头动作 音乐 国内竞争对手情况 国际竞争对手情况 波澜壮阔风云变幻 动机：一件事物，如果你并不足够了解它的过去，那你一定很难真正理解它的现在和未来。以史为鉴，可以知兴替已有的事，后必再有；已行的事，后必再行。日光之下，并无新事 纲要1998 互联网元年互联网元年第一次互联网大浪潮1994年—2000年从四大门户到搜索第一次大浪潮奠定BAT 马化腾在深圳创建了腾讯三大门户新浪成立，网易邮件，搜狐网上线 – 互联网1.0时代 1994年4月20日是中国互联网发展史上值得铭记的一天。这一天，我国实现与国际互联网的第一条TCP/IP全功能链接，成为全球互联网大家庭中的一员。 1995年5月，张树新和她的瀛海威公司，在北京中关村南大街树起了一块巨型广告牌：“中国人离信息高速公路还有多远？向北1500米”，推出全中文的“瀛海威时空”网络，面向普通家庭开放，成为中国第一个互联网接入服务商。 1998年3月6日，在媒体工作的王轲平通过登录中国银行网上银行，从世纪互联公司成功购买到10小时的上网时间，完成了中国第一单网上电子交易，电子商务不再是遥不可及的梦想 互联网1.0时代的特点是网站总是处于互动的主动一方，用户处于被动的一方。网站提供上网方式，提供内容，并且引导用户访问他们自己感兴趣的内容。信息流单一地从门户网站或二级网站向用户推送，这种模式与报纸、广播和电视是完全相同的。留言板BBS是用户唯一可以主动发言的地方。 正因为信息的单向流动，因此，在互联网1.0时代，网民们想拥有发言权的唯一途径是自己创办网站。在2000年左右，全世界各种网站如雨后春笋般地涌现出来，造成了“供大于求”的局面，这也促成了2000年底到2002年的互联网泡沫的崩溃，99%的网站都关门大吉了。 互联网泡沫的崩溃，从互联网的进化来说未尝不是一件好事，它清除了很多没有太大价值的网站，为互联网2.0的发展铺平了道路。 1999阿里巴巴成立腾讯OICQ运营 2000百度成立，BAT三大巨头聚首，各自发展谷歌96年成立，未进入中国市场 三大门户登录纳斯达克 2001第二次互联网大浪潮（2001年—2008年）从搜索到社交化网络(博客、sns、论坛、微博) 互联网泡沫美国互联网公司市值网易 大话西游 2002博客网成立，个人门户兴起，互联网门户进入2.0时代 一家互联网2.0公司需要具备下面这些全部，至少是部分特征：第一，必须有一个平台，可以接受并管理用户提交的内容，这些内容是服务的主体;第二，提供一个开放的平台，让用户可以在平台上开发自己的应用程序，并提供给其他用户使用;第三，交互性;第四，非竞争性和自足性。 泡沫期迅雷 下载工具同期竞品介绍 BT下载 2003国内电商元年 非典淘宝网支付宝 腾讯 QQ游戏 2004网游市场风起云涌 腾讯 港交所上市刘强东 京东成立贾跃亭 乐视 网易 梦幻西游搜狐 搜狗 2005博客元年 百度 纳斯达克上市 王兴创立校内网周鸿祎成立奇虎360古永锵创立优酷网 新浪推出新浪博客腾讯收购Foxmail 2006搜狐 搜狗拼音输入法网易 有道搜索谷歌中国成立 熊猫烧香病毒网络病毒利益链开始浮现 2007阿里巴巴 香港上市腾讯推出两款游戏：穿越火线 地下城与勇士 上海巨人网络科技有限公司在美国纽约证券交易所挂牌，成为首家在纽约证券交易所上市的中国网络公司，并成为中国市值最高的网络游戏企业 2008中国北京 奥运会 从2008年5月开始，开心网、校内网等SNS（Social Networking Service）网站迅速传播，SNS成为2008年的热门互联网应用之一SNS社交网站活跃,人人网（校内网）、开心网、QQ、等SNS平台为代表 搜索引擎竞价排名模式 2009第三次互联网大浪潮（2009年—2014年）PC互联网到移动互联网 中国的3G元年,工信部向中国移动、中国电信、中国联通分别发放了三张3G牌照 入口从搜索到各种各样app分流 从2009年下半年起，新浪网、搜狐网、网易网、人民网等门户网站纷纷开启或测试微博功能。微博客吸引了社会名人、娱乐明星、企业机构和众多网民加入，成为2009年热点互联网应用之一 搜狐畅游 纳斯达克上市腾讯游戏 英雄联盟新浪 推出新浪微博网易 代理魔兽世界人人网上线 2009年12月初，广播电影电视总局在清理整顿违法、违规视听节目网站的过程中，关闭包括BT中国联盟在内的530多家BT（BitTorrent）网站 2010团购网站兴起，数量超过1700家，团购成为城市一族最潮的消费和生活方式 优酷 纽交所上市乐视 创业板 雷军 创办小米王兴建立美团网爱奇艺上线 网易 网易微博阿里 手机淘宝 2010年10月29日，北京奇虎科技有限公司推出名为“扣扣保镖”的安全工具，11月3日，深圳市腾讯计算机系统有限公司指出“扣扣保镖”劫持了QQ的安全模块，并决定在装有360软件的电脑上停止运行QQ软件。11月4日，政府主管部门介入调查，在有关部门的干预下，双方的软件恢复兼容 谷歌 中文搜索转到香港 2011微博迅猛发展 腾讯 微信入股华谊兄弟入股金山软件 新浪 注资土豆 人人网 纽交所上市收购56网 奇虎360 纽交所上市 2012微信朋友圈今日头条 阿里 港交所退市改名天猫双11爆发 被业内称为双十一的爆发点，这一年淘宝商城正式更名为天猫。2012年双十一当日，天猫与淘宝的总销售额达到191亿，其中天猫达到132亿淘宝也有59亿 优酷土豆合并 2012年8月16日，奇虎360综合搜索上线，自此引发了百度和360的搜索之争 2013余额宝开创了国内互联网金融的先河 腾讯 注资滴滴打车收购搜狗股份 爱奇艺 收购PPS 网易网易理财炉石传说 2014打车软件烧钱发红包,滴滴快的巨资红包抢用户，“互联网+交通”出行 截止到2014年底，全球接入网络的人数已达到29亿(占全球人口数的40%) 阿里 纽交所上市蚂蚁金服成立 京东 纳斯达克上市新浪 微博纳斯达克上市 腾讯认购大众点评股份认购京东股份 滴滴 更名为滴滴打车戴威创办ofo 谷歌被屏蔽 2015首次提出“互联网+” 阿里 收购优酷腾讯收购盛大文学入股饿了么投资58同城 滴滴快的合并ofo在北京发布 2016魏则西事件互联网直播、网红等热词“风靡全国”, 短视频造就第一网红papi酱 知识付费掘起喜马拉雅FM中国第一个知识内容狂欢节，称为“123知识狂欢节”,消费超过5000万d 滴滴收购Uber中国小米，滴滴注资ofo奇虎360 纽交所退市京东收购1号店腾讯投资易车网注资酷我酷狗 2017自媒体百家争鸣,互联网BAT第一梯队,第二梯队等纷纷砸金压自媒体平台,(百家号,搜狐号,网易号,大yu号、京东号、迅雷号等) 腾讯腾讯音乐成立入股中国联通入股唯品会 奇虎360 借壳上市A股 阿里注资ofo 2018 寒冬到来2019参考 中国各行业著名网站成立时间：搜索：百度(2000)、好搜（2012原360搜索）、搜狗（2004）新闻：腾讯（1998）、新浪（1998）、搜狐（1998）、网易（1997）、凤凰（1996）、新华（1997）支付：支付宝（2004）、招行网银（1997）网购：淘宝（2003）、天猫（2008原淘宝商城）、京东（2004）音乐：百度音乐（2002原百度MP3）、酷狗音乐（2009）、QQ音乐（2004）视频：优酷（2006）、土豆（2005）、爱奇艺（2010）、cntv（2009）社交：QQ空间（2004）、微博（2006原新浪微博）旅游：百度旅游（2011）、携程（1999）学习：百度百科（2006）、互动百科（2005） 互联网刚刚进入中国的前10年，国内互联网企业基本处于模仿和学习阶段。三大门户新浪、搜狐和网易，师从雅虎；现在如日中天的BAT三巨头，百度学习谷歌、阿里巴巴学习亚马逊和EBAY、腾讯学习ICQ 大事记 三大门户新浪网易搜狐 2000年左右三大门户网站的，分别是新浪，搜狐和网易师从雅虎1994年杨致远和大卫-费罗创办了雅虎，并于两年后在华尔街上市，雅虎是门户的鼻祖，核心模式是在互联网上给用户提供资讯，它也是第一代互联网巨头 凭借着最新的新闻资讯，个人网站主页和bbs，在之前获得了很大的访问 网易的发展新闻门户邮箱游戏音乐电商 - 网易严选养猪 新浪新闻门户博客微博 搜狐新闻门户张朝阳搜狗畅游视频 巨头腾讯QQ微信电商 淘宝 天猫支付 支付宝 微信支付京东京东物流京东金融 2013诺基亚 2018小米上市美团上市ofo与摩拜","link":"/2020/02/25/internet-events/"},{"title":"Docker镜像下载加速器","text":"配置DaoCloud加速器：1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://b18c7aa2.m.daocloud.io 配置阿里云加速器：1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s https://zf0ry6xq.mirror.aliyuncs.com 查看加速配置信息：1docker info 配置完成后需要重启docker服务：1systemctl restart docker 或 1service docker restart 参考DaoCloud官网","link":"/2019/08/14/docker/docker-accelerator/"},{"title":"Docker compose file 配置参考","text":"示例配置：123456789101112131415161718192021222324252627282930313233version: &quot;3&quot;services: redis: image: redis:alpine ports: - &quot;6379&quot; networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure db: image: postgres:9.4 volumes: - db-data:/var/lib/postgresql/data networks: - backend deploy: placement: constraints: [node.role == manager]networks: frontend: backend:volumes: db-data: version: services: deploy - 应用发布配置restart_policy - 应用发布重启策略 12345678910version: &quot;3&quot;services: redis: image: redis:alpine deploy: restart_policy: condition: on-failure delay: 5s max_attempts: 3 window: 120s condition: 可选项 none on-failure any(default) delay: 尝试重启等待时间，默认0s max_attempts: 最大重启次数，默认无限，首次启动不计入 window: 判定重启是否成功等待时长，默认0s update_config - 应用发布更新策略 123456789101112version: &apos;3.4&apos;services: vote: image: dockersamples/examplevotingapp_vote:before depends_on: - redis deploy: replicas: 2 update_config: parallelism: 2 delay: 10s order: stop-first 官方参考文档地址：https://docs.docker.com/compose/compose-file","link":"/2019/08/14/docker/docker-compose-file/"},{"title":"Docker Portainer 容器管理工具","text":"portainer 持久化 数据文件夹/home/portainer/data 12volumes: - /home/portainer/data:/data","link":"/2019/08/31/docker/docker-portainer/"},{"title":"Docker 镜像清理","text":"12345678910# 删除所有 Docker 镜像docker rmi $(docker images -f &quot;dangling=true&quot; -q)# 删除所有未运行 Docker 容器docker rm $(docker ps -a -q)# 删除所有未打 tag 的镜像docker rmi $(docker images -q | awk &apos;/^&lt;none&gt;/ { print $3 }&apos;)# 删除所有镜像docker rmi $(docker images -q)#根据格式删除所有镜像docker rm $(docker ps -qf status=exited)","link":"/2019/08/14/docker/docker-image-manage/"},{"title":"Docker Swarm 集群","text":"swarm指定副本数，服务运行节点数–replicas 3 docker service update更新docker service–update-delay 设置延迟时间–update-parallelism 并行更新数–update-failure-action 失败后行为–update-max-failure-ratio 失败比例–update-monitor 更新监控时间 –rollback 回滚","link":"/2019/08/31/docker/docker-swarm/"},{"title":"Docker 安装","text":"系统：CentOS系统 安装脚本方式： 1curl -fsSL https://get.docker.com/ | sh 可选用阿里镜像站点安装：参考 https://yq.aliyun.com/articles/110806 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun centos命令1234service docker startservice docker stopservice docker statusservice docker restart docker命令123456docker psdocker imagesdocker rm #{container_id}docker rmi #{image_id}# 进入运行中的容器docker exec -it d48b21a7e439 /bin/sh # d48b21a7e439 - 容器id，container_id 设置镜像加速： 1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://b18c7aa2.m.daocloud.io Dockerfile123456789FROM openjdk:8-jre-alpineLABEL maintainer=\"username@gmail.com\"ARG JAR_FILE=target/ec-so-rest*.jarADD ${JAR_FILE} /app/ec-so-rest.jarCMD [\"java\", \"-Xmx2048m\", \"-XX:-UseGCOverheadLimit\", \"-jar\", \"/app/ec-so-rest.jar\"]EXPOSE 8080 FROM 为后续的命令设置基础镜像，它是Dockerfile文件的第一条命令 LABEL 为镜像添加一些描述的元数据 ARG 设置环境变量, 与ENV相比不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的 ADD 用于从当前机器或远程URL中的中拷贝文件、目录，并将它们添加到镜像文件系统的中 格式： 1ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt; CMD 为容器提供一个默认的执行命令，在一个Dockerfile只能有一条CMD指令，如果设置多条CMD指令，只有最后一条CMD指令会生效 EXPOSE 设置暴露的端口, 容器在运行时将监听指定哪个指定的网络端口。并可以指定端口的协议是TCP或UDP，如果没有指定协议，则默认为TCP协议 Docker hub 镜像站点docker 官方：https://hub.docker.com/explore/DaoCloud：https://hub.daocloud.io/阿里云：https://dev.aliyun.com/search.html Docker 镜像清理12345678910# 删除所有 Docker 镜像docker rmi $(docker images -f &quot;dangling=true&quot; -q)# 删除所有未运行 Docker 容器docker rm $(docker ps -a -q)# 删除所有未打 tag 的镜像docker rmi $(docker images -q | awk &apos;/^&lt;none&gt;/ { print $3 }&apos;)# 删除所有镜像docker rmi $(docker images -q)#根据格式删除所有镜像docker rm $(docker ps -qf status=exited)","link":"/2019/08/14/docker/docker/"},{"title":"Docker Ghost 安装","text":"GhostGhost 是基于 Node.js 的开源博客平台，目的是为了给用户提供一种更加纯粹的内容写作与发布平台。 启动命令：1docker run -d -name ghost -p 80:2368 -v /root/ghost/data:/var/lib/ghost/content ghost 释义：12345docker run -d \\ #创建一个后台运行容器，并返回容器ID --name ghost \\ #为容器指定一个名称 -p 80:2368 \\ #将容器的80端口映射到主机的80端口 -v /root/ghost/data:/var/lib/ghost/content \\ #主机的目录/root/ghost/data映射到容器的目录/var/lib/ghost/content ghost #使用docker官方镜像ghost:latest 参考GhostGhost中文网","link":"/2019/08/18/docker/ghost/"},{"title":"Docker Nginx 安装","text":"1234567docker run -d --name nginx \\ -v /usr/share/nginx/nginx.conf:/etc/nginx/nginx.conf:ro -v /usr/share/nginx/html:/usr/share/nginx/html:ro \\ -v /usr/share/nginx/log:/var/log/nginx \\ -p 80:80 \\ --restart=always \\ nginx 简化版： 1docker run -d --name nginx -p 80:80 daocloud.io/library/nginx:latest","link":"/2019/08/18/docker/nginx/"},{"title":"Git cherry-pick 摘樱桃","text":"cherry-pick，顾名思义：摘樱桃。如果说每一次commit是一颗樱桃，那么你可以通过cherry-pick命令将这一颗樱桃采摘到另外一颗樱桃树(branch)上。命令： 1git cherry-pick [--no-commit] 997367b(commit id) –no-commit:预计可能会出现冲突的时候，建议这样用，以便先自查并解决冲突后再手动提交 commit id:可通过git log来查看，该命令执行后会把997367b这颗樱桃复制到当前分支并自动commit(如果没有冲突的话) 注意一点，cherry-pick产生的提交与原提交commit id不同","link":"/2019/08/09/git/git-cherry-pick/"},{"title":"Git-查看代码提交次数","text":"Git仓库代码提交次数：git log –pretty=tformat: –numstat | awk ‘{ add += $1; subs += $2; loc += $1 - $2 } END { printf “added lines: %s, removed lines: %s, total lines: %s\\n”, add, subs, loc }’ - 代码新增修改总计行数：git log –pretty=tformat: –numstat | awk ‘{ add += $1; subs += $2; loc += $1 - $2 } END { printf “added lines: %s, removed lines: %s, total lines: %s\\n”, add, subs, loc }’ -","link":"/2019/08/09/git/git-commit-count/"},{"title":"git-delete-tags","text":"查看远程Tag git ls-remote –tags 删除远程主机指定Tag git push origin :refs/tags/","link":"/2020/04/10/git/git-delete-tags/"},{"title":"Git 对比分支差异","text":"查看dev分支有而master分支没有的提交： 1git log dev ^master","link":"/2019/08/31/git/git-diff/"},{"title":"Git 修改远程主机地址","text":"可直接修改远程主机地址： git remote set-url origin [url] 其中origin为远程主机名称，url为要设置的远程主机地址例如：git remote set-url origin gitlab@gitlab.chumob.com:php/hasoffer.git 删除远程主机后重新添加 git remote rm origingit remote add origin [url]","link":"/2019/08/31/git/git-remote/"},{"title":"Git Subtree","text":"推送指定文件夹到远程主机指定分支1git subtree push --prefix public origin master public - 指定文件夹master - 指定分支","link":"/2019/08/09/git/git-subtree/"},{"title":"Git常用操作命令","text":"git config 设置查看当前配置 1git config -l 设置默认用户名邮箱 12git config --global user.name &quot;test&quot;git config --global user.email&quot;test@gmail.com&quot; 保存密码 1git config --global credential.helper store 设置默认使用sublime编辑器 1git config --global core.editor =&quot;&apos;D:/Program Files/Sublime Text 3/sublime_text.exe&apos; -w&quot; # 设置Editor使用sublime 设置别名 1234567git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global alias.pb &apos;pull --rebase&apos;git config --global alias.dt difftoolgit config --global alias.mt mergetool 设置beyond compare 作为默认对比工具&amp;合并工具 - 修改gitconfig配置文件 12345678910111213141516[diff] tool = bc4 algorithm = histogram[difftool] prompt = false[difftool &quot;bc4&quot;] cmd = \\&quot;D:/Program Files/beyond compare/BComp.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot;[merge] tool = bc4[mergetool] prompt = false keepBackup = false[mergetool &quot;bc4&quot;] cmd = \\&quot;D:/Program Files/beyond compare/BComp.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; \\&quot;$BASE\\&quot; \\&quot;$MERGED\\&quot; trustExitCode = true 代理设置 12git config --global http.proxy 127.0.0.1:1080git config --global https.proxy 127.0.0.1:1080 取消代理配置 12git config --global --unset http.proxygit config --global --unset https.proxy Git 流程只克隆指定分支 123git clone -b &lt;branch&gt; &lt;remote_repo&gt; 例如： git clone -b 指定的分支名字git clone -b csvjob https://用户名:密码@github.com/yamibuy/IM-backend-service.gitgit clone -b v3.1.0 https://github.com/yamibuy/central-hub-web.git hub # 指定分支和目录 代码提交 1234567891011121314151617git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add .# 将所有修改过的工作文件提交暂存区git ci .git ci -agit ci -am &quot;some comments&quot;git ci --amendgit co -- &lt;file&gt; # 抛弃工作区修改git co .# 抛弃工作区修改git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git revert HEAD 对比 12git dtgit mt 历史 12git loggit log -3 分支 1234567891011121314git brgit br -agit br -rgit br &lt;new_branch&gt;git br -d &lt;branch&gt;git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)git co &lt;branch&gt;git co -b &lt;new_branch&gt; git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git merge &lt;branch&gt; # 将branch分支合并到当前分支 git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; 暂存 1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 远程主机 1234567891011121314151617git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote rm &lt;repository&gt; # 删除远程仓库git pull # 抓取远程仓库所有分支更新并合并到本地git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支git branch --set-upstream origin/master 设置跟踪远程仓库 帮助 1git help &lt;command&gt;","link":"/2019/08/31/git/git/"},{"title":"Github Pages Vue 项目发布","text":"使用Github Pages搭建Vue项目在线演示demo分支：gh-pages访问Url：https://[user_name].github.io/[project_name]关键点：利用Github提供的静态页解析功能, 将静态页面推送到Github个人项目仓库的gh-pages分支下 在现有vue项目的基础上，执行以下步骤：12345678910# 1.切换分支git checkout gh-pages# 2.构建项目，生成build文件npm run build# 3.强制添加dist文件夹，因为.gitignore文件中定义了忽略该文件git add -f dist# 4.提交git commit -m &apos;Initial the page of project&apos;# 5.部署dist目录下的代码：使用git subtree命令可以在同一分支上维护源代码以及构建代码，在部署时仅仅推送dist目录下的内容git subtree push --prefix dist origin gh-pages 提示：在将Vue应用部署到gh-pages分支后，可能会出现部分资源无法加载的问题，原因就在于vue中的webpack配置在打包时其publicPath为根路径，如果该静态页在服务器中被访问则不会出现以上问题。在github解析时如果按照根路径解析会出错，因此在github上部署静态页时可以考虑将publicPath设置为当前目录，即 publicPath: ‘./‘。同理，使用Vue-cli webpack模板生成的vue项目，出现上述问题应设置config/index.js中build对象下的assetsPublicPath字段为assetsPublicPath: ‘./‘,原理都是设置publicPath字段","link":"/2019/08/10/git/github-pages-vue/"},{"title":"hexo 命令","text":"hexo version显示 Hexo 版本。 hexo init [folder]新建网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 hexo g生成静态文件。 12hexo generatehexo g 监控文件变动，实时编译 12hexo generate --watchhexo g -w 生成静态文件后立即部署网站 12hexo generate --deployhexo g -d 强制重新生成文件 12hexo generate --forcehexo g -f hexo s启动服务器。默认情况下，访问网址为： http://localhost:4000/。-p 或 –port 参数可指定端口 12hexo serverhexo s 参数： -p 重设端口 -s 只使用静态文件 -l 启动日志记录 hexo d部署网站。 12hexo deployhexo d 部署之前预先生成静态文件 12hexo deploy --generatehexo d -g hexo new ‘文章标题’新建文章。如果标题包含空格，使用引号括起来。eg: 1hexo new &quot;post title with whitespace&quot; hexo list 列出网站资料。Description:List the information of the site.Arguments: type Available types: page, post, route, tag, category 12hexo list posthexo list tag hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。","link":"/2019/08/08/hexo/hexo-command/"},{"title":"hexo 博客搭建","text":"安装nodenode -vnpm -v gitgit version github个人仓库username.github.io hexo12npm install -g hexo-clihexo version 创建网站123hexo init blogcd blognpm install 文章1hexo new &apos;文章标题&apos; 执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件 启动服务启动前先编译生成静态文件 1hexo g 1hexo s 默认访问地址：http://localhost:4000 部署hexo 博客部署 访问网站链接 域名绑定TODO 扩展主题修改下载主题文件到主目录： 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 修改主目录下的_config.yml，指向自定义的主题： 1theme: {#theme-title} theme-title: 自定义主题的名称 主题定制字体修改：主题source文件夹下css目录示例： 1family-sans = \"Open Sans\", \"Helvetica Neue\", \"Microsoft YaHei\", sans-serif 内容区宽度, 修改layout.ejs文件中的 1is-8-tablet is-8-desktop is-8-widescreen 为 1is-9-tablet is-9-desktop is-9-widescreen 同时，修改widget.ejs文件 参考：BulmaCSS 框架 Bulma 教程 文章内链1{% post_link post-title-sample 点此查看 %} post-title-sample - 文章名称，如果文章不存在，这段代码将会被直接忽略。 点此查看 - 链接标题。如果置空，则自动提取文章的标题。 文章标签遵循yaml文件格式 12tags：tag-nametags: [tag-name1, tag-name2] 参考：http://www.ruanyifeng.com/blog/2016/07/yaml.html 插件代码着色https://github.com/highlightjs/highlight.jshttps://highlightjs.org/推荐样式：monokai-sublime 实时预览BrowserSync plugin for Hexo. 1npm install hexo-browsersync --save 自动摘要1npm install hexo-excerpt --save","link":"/2019/08/08/hexo/hexo-create/"},{"title":"hexo 博客部署","text":"发布流程 - V2 安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 修改_config.yml配置 12345deploy: type: git repo: https://github.com/username/username.github.io.git branch: master message: 编译 1hexo g 部署 1hexo d 以上两步可以使用单条命令进行简化： 1hexo g -d # 意为生成静态文件后立即部署网站 等待2min左右，页面展示。 V2流程中, 步骤1、2只需执行一次。 原理当初次新建一个库的时候，库将自动包含一个master分支。请在这个分支下进行写作和各种配置来完善您的网页。当执行hexo deploy时，Hexo会创建或更新另外一个用于部署的分支，这个分支就是_config.yml配置文件中指定的分支。Hexo会将生成的站点文件推送至该分支下，并且完全覆盖该分支下的已有内容。因此，部署分支应当不同于写作分支。（一个推荐的方式是把master作为写作分支，另外使用public分支作为部署分支。）值得注意的是，hexo deploy并不会对本地或远程的写作分支进行任何操作，因此依旧需要手动推送写作分支的所有改动以实现版本控制。此外，如果您的Github Pages需要使用CNAME文件自定义域名，请将CNAME文件置于写作分支的source_dir目录下，只有这样hexo deploy才能将CNAME文件一并推送至部署分支。 发布流程 - V1 编译：hexo g src分支代码提交 xshell同步到阿里云服务器 服务器端git提交 等待2min左右，页面展示 Tip：服务器初次提交Git配置： 12git config --global user.email &quot;username@xx.com&quot;git config --global user.name &quot;username&quot; 提交时输入username和密码。 搜索收录SEO查看网站是否被Google收录： 1site:http://xxxx.github.io 站点地图生成插件安装 1npm install hexo-generator-sitemap --save 配置文件_config.yml中添加： 12sitemap: path: sitemap.xml 之后在每一次执行hexo g编译命令时，sitemap会自动更新 参考：让Google搜索到搭建在Github Pages上的博客Google Search Console","link":"/2019/08/09/hexo/hexo-deploy/"},{"title":"android","text":"版本 9 IDEAndroid Studio valval a: Int = ch.toInt(); var 变量val 常量 常量不能再次更改 boolean arrayOf Array 日志 swith ==&gt; when for 倒序遍历 init 主构造函数 lateinit 懒加载internal 模块内部可见 inner class 内部类 function ==&gt; fun 四大组件activity 页面 生命周期service 后台 如音乐播放器broadcast receivers 广播接收器 注册监听 顺序 优先级content providers 内容提供者组件 Intent 组件间传值 隐式意图 五大布局 数据库访问 动画 混淆签名打包发布 data class 与 普通class 为什么不用java用kotlin http调用 okhttp 第三方包引用反编译 页面复用 css样式 框架","link":"/2019/08/10/java/android/"},{"title":"死锁","text":"for update 是否锁表 事务传播 @Transactional 异常 MySQLTransactionRollbackException 隔离级别 12345678show engines;show variables like '%storage_engine%';select version();select @@tx_isolation; -- 查看数据库隔离级别select @@autocommit;show variables like 'innodb_lock_wait_timeout';show global variables like 'innodb_lock_wait_timeout';set innodb_lock_wait_timeout=1000; -- 设置当前会话 Innodb 行锁等待超时时间，单位秒 INNODB 事务 12345678910111213141516SELECT `trx_id`, `trx_state` AS 事务状态, `trx_started` AS 开始时间, `trx_requested_lock_id`, `trx_wait_started`, `trx_weight` AS 权重, `trx_mysql_thread_id` AS 线程ID, `trx_query`, `trx_operation_state`, `trx_tables_locked` AS 锁表个数, `trx_rows_locked` AS 锁表行数, `trx_rows_modified` AS 修改行数, `trx_autocommit_non_locking` AS 是否自动提交FROM INNODB_TRX t; 场景模拟","link":"/2019/08/13/java/deadlock/"},{"title":"设计模式","text":"","link":"/2019/08/10/java/design-pattern/"},{"title":"druid数据库连接池通用配置","text":"dependency123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; config12345678910111213141516171819202122232425262728293031323334&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=\"url\" value=\"${jdbc_url}\" /&gt; &lt;property name=\"username\" value=\"${jdbc_user}\" /&gt; &lt;property name=\"password\" value=\"${jdbc_password}\" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"maxActive\" value=\"20\" /&gt; &lt;property name=\"initialSize\" value=\"1\" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\" /&gt; &lt;property name=\"minIdle\" value=\"1\" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。 --&gt; &lt;property name=\"validationQuery\" value=\"SELECT 1\" /&gt; &lt;property name=\"testWhileIdle\" value=\"true\" /&gt; &lt;property name=\"testOnBorrow\" value=\"false\" /&gt; &lt;property name=\"testOnReturn\" value=\"false\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=\"filters\" value=\"stat\" /&gt; &lt;!-- 1.1.4中新增配置，如果有initialSize数量较多时，打开会加快应用启动时间 --&gt; &lt;property name=\"asyncInit\" value=\"true\" /&gt;&lt;/bean&gt; error: Error creating bean with name ‘dataSource’Druid连接池与spring cloud config搭配使用时出现异常错误堆栈信息： 123org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos;: Could not bind properties to DruidDataSourceWrapper (prefix=spring.datasource, ignoreInvalidFields=false, ignoreUnknownFields=true, ignoreNestedProperties=false); nested exception is org.springframework.validation.BindException: org.springframework.boot.bind.RelaxedDataBinder$RelaxedBeanPropertyBindingResult: 3 errorsField error in object &apos;spring.datasource&apos; on field &apos;driverClassName&apos;: rejected value [com.mysql.jdbc.Driver]; codes [methodInvocation.spring.datasource.driverClassName,methodInvocation.driverClassName,methodInvocation.java.lang.String,methodInvocation]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [spring.datasource.driverClassName,driverClassName]; arguments []; default message [driverClassName]]; default message [Property &apos;driverClassName&apos; threw exception; nested exception is java.lang.UnsupportedOperationException]Field error in object &apos;spring.datasource&apos; on field &apos;url&apos; 异常出现代码位置： 1234567891011public void setDriverClassName(String driverClass) { if (inited) { if (StringUtils.equals(this.driverClass, driverClass)) { return; } throw new UnsupportedOperationException(); } this.driverClass = driverClass;} 代码中如有@PostConstruct并在其中进行了对数据库查询更新等于数据源有关的操作，则会出现此错误 解决办法: 升级druid版本 参考https://github.com/alibaba/druid/wiki/常见问题","link":"/2019/08/13/java/druid/"},{"title":"Eclipse - Java开发工具","text":"Why Eclipse默认配置的热部署：方法内部代码修改无需重新启动 安装设置 字体设置 workspace 编码设置 installed jres package explorer startup and shutdown compare Ignore white space Swap left and right 可选： sonar server 中文语言包 自动升级 原文链接：https://download.eclipse.org/releases/2019-06/ 格式代码风格：google style文件链接： Eclipse：https://github.com/google/styleguide/blob/gh-pages/eclipse-java-google-style.xml IDEA：https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml 参考：https://google.github.io/styleguide/javaguide.html译文参考：https://www.jianshu.com/p/c0e5a4a896be","link":"/2019/08/10/java/eclipse/"},{"title":"guava - Java开发工具","text":"ListsArrays","link":"/2019/08/10/java/guava/"},{"title":"java-8","text":"Stream APIlambda Date-Time","link":"/2019/08/13/java/java-8/"},{"title":"lambda","text":"","link":"/2019/08/10/java/lambda/"},{"title":"lombok","text":"dependency123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; IDE支持EclipseIDEA @Data@Getter@Setter@Slf4j@AllArgsConstructor@EqualsAndHashCode@Builder","link":"/2019/08/13/java/lombok/"},{"title":"Maven常用功能","text":"常用命令12345mvn cleanmvn packagemvn installmvn clean package -DskipTestsmvn clean package -DskipTests -U mvn install 会将项目生成的构件安装到本地Maven仓库 mirror阿里镜像： 123456&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;human readable name for this mirror.&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; nexusmaven私服 配置参考配置文件路径(示例)：C:\\Users\\username.m2\\settings.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository/&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://private.mvnrepository.com/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;username&lt;/username&gt; &lt;password&gt;password&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;human readable name for this mirror.&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 上传至私服1mvn deploy 用来将项目生成的构件分发到远程Maven仓库 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Release&lt;/name&gt; &lt;url&gt;http://private.mvnrepository.com/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Snapshot&lt;/name&gt; &lt;url&gt;http://private.mvnrepository.com/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; Maven区别对待release版本的构件和snapshot版本的构件，snapshot为开发过程中的版本，实时，但不稳定，release版本则比较稳定。Maven会根据你项目的版本来判断将构件分发到哪个仓库。 snapshot 更新策略maven对构件的更新判断基本上是两种，一种是稳定版本，一种是maven特有的SNAPSHOT版本。稳定版本很好判断，直接根据maven构件的坐标体系就能够获得。先从本地仓库中找，如果本地仓库没有，就从pom.xml和setting.xml配置的远程仓库来找。SNAPSHOT版本的判断比较麻烦，基本步骤如下：假设我在2014年08月22日09时40分52秒在我自己的电脑上使用 “mvn install” 构建了“com.mycompany.demo:test:1.0-SNAPSHOT”。那么Maven会在本地仓库目录“~/.m2/com/mycompany/demo/test/1.0-SNAPSHOT/”下生成文件“maven-metadata-local.xml”，内容如下： 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;metadata modelVersion=\"1.1.0\"&gt; &lt;groupId&gt;com.mycompany.demo&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;versioning&gt; &lt;snapshot&gt; &lt;localCopy&gt;true&lt;/localCopy&gt; &lt;/snapshot&gt; &lt;lastUpdated&gt;20140822084052&lt;/lastUpdated&gt; &lt;snapshotVersions&gt; &lt;snapshotVersion&gt; &lt;extension&gt;jar&lt;/extension&gt; &lt;value&gt;1.0-SNAPSHOT&lt;/value&gt; &lt;updated&gt;20140822084052&lt;/updated&gt; &lt;/snapshotVersion&gt; &lt;snapshotVersion&gt; &lt;extension&gt;pom&lt;/extension&gt; &lt;value&gt;1.0-SNAPSHOT&lt;/value&gt; &lt;updated&gt;20140822084052&lt;/updated&gt; &lt;/snapshotVersion&gt; &lt;/snapshotVersions&gt; &lt;/versioning&gt;&lt;/metadata&gt; 十点钟的时候，其他同事更新了com.mycompany.demo:test:1.0-SNAPSHOT的内容，并通过 “mvn deploy” 发布到了公司的Maven服务器上。公司Maven服务器上产生了文件：test-1.0-20140822.100021-1.jar, test-1.0-20140822.100021-1.pom并更新了maven-metadata.xml，内容如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;metadata modelVersion=\"1.1.0\"&gt; &lt;groupId&gt;com.mycompany.demo&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;versioning&gt; &lt;snapshot&gt; &lt;timestamp&gt;20140822.100021&lt;/timestamp&gt; &lt;buildNumber&gt;34&lt;/buildNumber&gt; &lt;/snapshot&gt; &lt;lastUpdated&gt;20140822100021&lt;/lastUpdated&gt; &lt;snapshotVersions&gt; &lt;snapshotVersion&gt; &lt;extension&gt;jar&lt;/extension&gt; &lt;value&gt;1.0-20140822.100021-1&lt;/value&gt; &lt;updated&gt;20140822100021&lt;/updated&gt; &lt;/snapshotVersion&gt; &lt;snapshotVersion&gt; &lt;extension&gt;pom&lt;/extension&gt; &lt;value&gt;1.0-20140822.100021-1&lt;/value&gt; &lt;updated&gt;20130407081828&lt;/updated&gt; &lt;/snapshotVersion&gt; &lt;/versioning&gt; &lt;/metadata&gt; ```xml 在这期间我的电脑上没有发生过任何关于test的构建。 某一天，我需要构建一个依赖于test的项目，于是我运行了mvn package来打包。这个时候，maven做了什么呢（背景：我通过配置镜像，使我本地Maven的任何资源都是从公司的Maven服务器下载的）？ - Step1：从公司的Maven服务器上下载maven-metadata.xml，重命名为“maven-metadata-&lt;RepositoryID&gt;.xml”，并保存到本地仓库相应目录。 - Step2：比较maven-metadata-local.xml与maven-metadata-&lt;RepositoryID&gt;.xml中的lastUpdated时间戳的值。 如果maven-metadata-local.xml中的时间戳比较大，则终止。 如果maven-metadata-&lt;RepositoryID&gt;.xml中的时间戳较大，则从公司Maven服务器上下载最新版本。即：testu-1.0.1-20130407.081828-34.jar。 这个过程分两步： （1）下载test-1.0-20140822.100021-1.jar到本地Maven仓库。 （2）将test-1.0-20140822.100021-1.jar复制一份，覆盖掉原先的test-1.0-SNAPSHOT.jar。也就是说，如果Maven从远程仓库下载了最新的SNAPSHOT发布包的话，那么最新的待时间戳的包和xxx-SNAPSHOT包是完全一样的。 作者：邓涛 链接：https://www.zhihu.com/question/24930782/answer/29532274 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2019/08/10/java/maven/"},{"title":"PDFBox使用指南","text":"1. 介绍Apache PDFBox是一个开源Java库，支持PDF文档的开发和转换。使用该库可以开发创建，转换和操作PDF文档的Java程序。 2. 特性 提取文本 - 使用PDFBox，您可以从PDF文件中提取Unicode文本。 拆分和合并 - 使用PDFBox，您可以将单个PDF文件分成多个文件，并将它们作为单个文件合并。 填写表单 - 使用PDFBox，您可以填写文档中的表单数据。 打印 - 使用PDFBox，您可以使用标准Java打印API打印PDF文件。 另存为图像 - 使用PDFBox，您可以将PDF保存为图像文件，如PNG或JPEG。 创建PDF - 使用PDFBox，您可以通过创建Java程序创建新的PDF文件，还可以包括图像和字体。 签名 - 使用PDFBox，您可以将数字签名添加到PDF文件。 3. 引入12345&lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.17&lt;/version&gt;&lt;/dependency&gt; 4. 应用示例4.1 PDFBox指定位置添加文本指定字体文件simsun.ttf支持添加中文文本 1234567891011121314151617181920212223242526PDDocument doc = null;try { File file = new File(\"C:\\\\origin.pdf\"); doc = PDDocument.load(file); String fontFilePath = \"C:\\\\simsun.ttf\"; PDType0Font font = PDType0Font.load(doc, new File(fontFilePath)); PDPage page = doc.getPage(0); PDPageContentStream contentStream = new PDPageContentStream(doc, page, PDPageContentStream.AppendMode.PREPEND, true); contentStream.beginText(); contentStream.setFont(font, 10); float offsetx = 40; float offsety = 105; contentStream.newLineAtOffset(offsetx, offsety); contentStream.showText(\"hello, world\"); contentStream.endText(); contentStream.close(); doc.save(\"C:\\\\result.pdf\"); doc.close();} catch (IOException e) { // TODO handle exception} 4.2 PDFBox加载ttc字体文件以宋体 - SimSun为例 1234567PDType0Font font;TrueTypeCollection trueTypeCollection = new TrueTypeCollection(new File(\"c:/windows/fonts/simsun.ttc\"));TrueTypeFont trueTypeFont = trueTypeCollection.getFontByName(\"SimSun\");if (null != trueTypeFont) { font = PDType0Font.load(doc, trueTypeFont, false);}trueTypeCollection.close(); 4.3 添加注释Annotation示例代码文件：https://github.com/apache/pdfbox/blob/2.0.17/examples/src/main/java/org/apache/pdfbox/examples/pdmodel/AddAnnotations.java 5. 参考 官网 https://pdfbox.apache.org/ Github Mirror https://github.com/apache/pdfbox PDFBox快速指南 http://www.vue5.com/pdfbox/pdfbox_quick_guide.html 6. 使用执行一次的任务： JDK / JRE pdf.zip C盘创建pdf文件夹，下载相应文件 可重复执行的任务： 将PDF复制到C盘pdf文件夹下，同时在此路径下使用sublime软件创建PDF同名文本文档(后缀为.txt) 在资源管理器地址栏中输入命令：cmd，打开命令行窗口 在命令行窗口中输入：java -jar de[Tab按键补全] 浏览器访问 http://localhost:8080/pdf 查看结果文件，存储在C盘pdf/result文件夹中","link":"/2019/10/30/java/pdfbox/"},{"title":"Postman","text":"Requestheadersbody PresetsCollectionExport &amp; ImportEnvironmentMockTest123456pm.test(\"Response is Success\", function () { pm.response.to.have.status(200); var jsonData = pm.response.json(); pm.expect(jsonData.success).to.eql(true); pm.expect(jsonData.messageId).to.eql(\"10000\");}); RunnerWorkspaceTeam","link":"/2019/08/10/java/postman/"},{"title":"mybatis","text":"batch update批量更新eg: 123456update table_post pinner join ( SELECT u.user_id,u.post_count FROM table_user u) as c_u on p.user_id = c_u.user_idset u.post_count=c_u.post_count; mapper中batch update写法： 123456789&lt;update id=\"batchUpdate\" parameterType=\"java.util.List\"&gt; &lt;foreach collection=\"list\" item=\"item\" index=\"index\" open=\"\" close=\"\" separator=\";\"&gt; update test &lt;set&gt; test=${item.test}+1 &lt;/set&gt; where id = ${item.id} &lt;/foreach&gt;&lt;/update&gt; TIP：数据库连接必须配置：&amp;allowMultiQueries=true 文档中文文档http://www.mybatis.org/mybatis-3/zh/ mybatis-springhttp://www.mybatis.org/spring/zh/ MyBatis Generatorhttp://www.mybatis.org/generator/http://generator.sturgeon.mopaas.com/ 工具http://www.mybatis.tk/","link":"/2019/08/13/java/mybatis/"},{"title":"sonar","text":"start123456789docker run -d --name sonarqube \\ -p 9797:9000 -p 9092:9092 \\ -v /opt/sonarqube/temp:/opt/sonarqube/temp \\ -v /opt/sonarqube/conf:/opt/sonarqube/conf \\ -v /opt/sonarqube/extensions:/opt/sonarqube/extensions \\ -e SONARQUBE_JDBC_USERNAME=username \\ -e SONARQUBE_JDBC_PASSWORD=password \\ -e SONARQUBE_JDBC_URL=\"jdbc:mysql://192.168.20.234:3306/sonar?useUnicode=true&amp;characterEncoding=utf8\" \\ sonarqube:7.1 plugins12345678FROM sonarqubeADD ./sonar-l10n-zh-plugin-1.15.jar /opt/sonarqube/extensions/plugins/sonar-l10n-zh-plugin-1.15.jarADD ./sonar-java-plugin-4.7.0.9212.jar /opt/sonarqube/extensions/plugins/sonar-java-plugin-4.7.0.9212.jarADD ./sonar-findbugs-plugin-3.4.4.jar /opt/sonarqube/extensions/plugins/sonar-findbugs-plugin-3.4.4.jarADD ./checkstyle-sonar-plugin-3.6.jar /opt/sonarqube/extensions/plugins/checkstyle-sonar-plugin-3.6.jarADD ./backelite-sonar-swift-plugin-0.3.2.jar /opt/sonarqube/extensions/plugins/backelite-sonar-swift-plugin-0.3.2.jarADD ./sonar-web-plugin-2.5.0.476.jar /opt/sonarqube/extensions/plugins/sonar-web-plugin-2.5.0.476.jarADD ./sonar-javascript-plugin-2.21.0.4409.jar /opt/sonarqube/extensions/plugins/sonar-javascript-plugin-2.21.0.4409.jar IDE SupportEclipseIDEA maven项目sonar扫描本地配置和扫描相关命令 1mvn sonar:sonar 术语 Reliability 可靠性 Security 安全 Maintainability 可维护性 Coverage 覆盖率 Duplications 重复 Quality Gate 质量门限 Compliant Solution 兼容的解决方案 sonar rules建议手工关闭的规则： Field names should comply with a naming convention Local variable and method parameter names should comply with a naming convention Method names should comply with a naming convention Fields in a “Serializable” class should either be transient or serializable Classes without “public” constructors should be “final” Overriding methods should do more than simply call the same method in the super class Static non-final field names should comply with a naming convention Utility classes should not have public constructors Abstract classes without fields should be converted to interfaces @FunctionalInterface annotation should be used to flag Single Abstract Method interfaces An abstract class should have both abstract and concrete methods “throws” declarations should not be superfluou Redundant modifiers should not be used Control structures should use curly braces Methods should not have too many return statements Generic exceptions should never be thrown","link":"/2019/08/13/java/sonar/"},{"title":"spring-boot-2.0","text":"context-path1234# 旧版server.context-path: xxxx# 新版server.servlet.context-path: xxxx ActuatorDependency1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; Endpoints执行器端点（endpoints）可用于监控应用及与应用进行交互 env 显示来自Spring的 ConfigurableEnvironment的属性 health 显示应用的健康信息 info 显示任意的应用信息 metrics 展示当前应用的metrics信息 mappings 显示一个所有@RequestMapping路径的集合列表 logfile 返回日志文件内容（如果设置了logging.file或logging.path属性的话） prometheus 以可以被Prometheus服务器抓取的格式显示metrics信息 启用禁用： 12management.endpoint.metrics.enabled=truemanagement.endpoint.env.enabled=true 隐藏暴露： 12management.endpoints.web.exposure.include=metricsmanagement.endpoints.web.exposure.exclude=env","link":"/2019/08/13/java/spring-boot-2.0/"},{"title":"spring-boot","text":"","link":"/2019/08/14/java/spring-boot/"},{"title":"spring-cloud-config","text":"dependency动态刷新使用限制@RefreshScope @Configuration 不能同时在一个类上使用原因说明： @RefreshScope works (technically) on an @Configuration class, but it might lead to surprising behaviour: e.g. it does not mean that all the @Beans defined in that class are themselves @RefreshScope. Specifically, anything that depends on those beans cannot rely on them being updated when a refresh is initiated, unless it is itself in @RefreshScope (in which it will be rebuilt on a refresh and its dependencies re-injected, at which point they will be re-initialized from the refreshed @Configuration). 参考：https://stackoverflow.com/questions/45137555/refreshscope-not-working-spring-boothttp://projects.spring.io/spring-cloud/spring-cloud.html#_refresh_scope","link":"/2019/08/13/java/spring-cloud-config/"},{"title":"spring-cloud","text":"registry注册中心Eureka Eureka自我保护机制springcloud服务已经关但是Eureka还是显示up，该状态持续很久，访问该服务也返回错误，但在注册中心界面，该服务却一直存在，且为UP状态，并且在大约十分钟后，出现一行红色大字：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.原因：自我保护机制。Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果出现低于的情况（在单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳定导致），Eureka Server会将当前的实例注册信息保护起来，同时提示这个警告。 进程间通信Feign 负载均衡客户端负载均衡Ribbon 分布式配置中心Spring Cloud Config动态刷新http://blog.didispace.com/springcloud4-2/消息总线 熔断器Hystrix 网关路由Zuul Zuul 管理端点routesGETPOST - 强制立即刷新当前映射的路由列表 Spring Cloud Gateway 重试参考示例应用：piggymetricshttps://github.com/sqshq/PiggyMetrics","link":"/2019/08/14/java/spring-cloud/"},{"title":"spring-retry","text":"Spring Retry实现重试操作 dependency1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 注解在启动入口加入重试配置 1@EnableRetry 使用1@Retryable(value = Exception.class, maxAttempts = 3,backoff = @Backoff(delay = 2000, multiplier = 1.5)) 参考 @EnableRetry 能否重试 @Retryable 标注此注解的方法在发生异常时会进行重试 value：指定处理的异常类 include：指定处理的异常类和value一样，默认为空，当exclude也为空时，默认所有异常 exclude：指定异常不处理，默认空，当include也为空时，默认所有异常 maxAttempts：最大重试次数。默认3次 backoff： 重试等待策略。默认使用@Backoff注解 @Backoff 重试等待策略 不设置参数时，默认使用FixedBackOffPolicy（指定等待时间），重试等待1000ms 设置delay,使用FixedBackOffPolicy（指定等待时间），重试等待填写的时间 设置delay和maxDealy时，重试等待在这两个值之间均态分布 设置delay、maxDealy、multiplier，使用 ExponentialBackOffPolicy（指数级重试间隔的实现 ），multiplier即指定延迟倍数，比如delay=5000l,multiplier=2,则第一次重试为5秒，第二次为10秒，第三次为20秒…… @Recover 用于@Retryable重试失败后处理方法，此注解注释的方法参数一定要是@Retryable抛出的异常，否则无法识别，可以在该方法中进行日志处理。","link":"/2019/08/15/java/spring-retry/"},{"title":"echarts - Angular 1.x指令集成","text":"html123456&lt;div ng-app=\"demo\" ng-controller=\"myCtrl\" id=\"demo\"&gt;&lt;div style=\"width: 640px; height: 320px;\" bar-chart e-data=\"data\"&gt;&lt;/div&gt;&lt;div style=\"width: 640px; height: 320px;\" pie-chart e-data=\"data\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- ... 省略文件中其他无关内容 --&gt;&lt;script src=\"js/echarts.min.js\"&gt;&lt;/script&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137var app = angular.module('demo', []); //定义一个模块angular.module('demo').controller(\"myCtrl\", function($scope, $http, $interval) { //定义控制器 $interval(function() { //调用$interval服务执行循环任务，3秒自动更新一次数据 $http.get(\"/demo_get\") //调用$http服务获取数据 .success(function(data) { if (data.status == '0') { $scope.data = data.data; //将数据放在model中 } }).error(function() { $scope.data[0].value = Math.floor(Math.random() * 2000); //模拟数据改变测试 }); }, 3000); //假设获取到的数据如下： $scope.data = [{ 'value': 335, 'name': '直接访问' }, { 'value': 310, 'name': '邮件营销' }, { 'value': 234, 'name': '联盟广告' }, { 'value': 135, 'name': '视频广告' }, { 'value': 748, 'name': '搜索引擎' }];});angular.module('demo').directive('barChart', function($window) { //定义条形图指令 return { restrict: 'A', //以属性的方式调用指令 link: function($scope, element, attrs) { //attrs是DOM元素的属性集合 var myChart = echarts.init(element[0]); //element是一个jqlite对象，如果jQuery在AngularJS之前引入,则是一个jQuery对象,可使用jQuery所有的方法 $scope.$watch(attrs.eData, function(newValue, oldValue, scope) { //监听属性e-data的值，当数据发生改变时执行作为第二个参数的函数 var xData = [], sData = [], data = newValue; //获取$scope.data angular.forEach(data, function(val) { xData.push(val.name); sData.push(val.value); }); var option = { title: { text: '某站点用户访问来源', subtext: '纯属虚构', x: 'center' }, color: ['#3398DB'], tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis: [{ type: 'category', data: xData, axisTick: { alignWithLabel: true } }], yAxis: [{ type: 'value' }], series: [{ name: '直接访问', type: 'bar', barWidth: '60%', data: sData }] }; myChart.setOption(option); }, true); //$watch的第三个参数，是否深度监听，true监听对象所有属性的变化。 $window.onresize = function() { //调用window服务，使图表能响应式调整大小 myChart.resize(); }; } };});angular.module('demo').directive('pieChart', function($window) { //定义饼图指令 return { restrict: 'A', link: function($scope, element, attrs) { //attrs是DOM元素的属性集合 var myChart = echarts.init(element[0]); $scope.$watch(attrs.eData, function(newValue, oldValue, scope) { var legend = []; angular.forEach(newValue, function(val) { legend.push(val.name); }); var option = { title: { text: '某站点用户访问来源', subtext: '纯属虚构', x: 'center' }, tooltip: { trigger: 'item', formatter: \"{a} &lt;br/&gt;{b} : {c} ({d}%)\" }, legend: { orient: 'vertical', left: 'left', data: legend }, series: [{ name: '访问来源', type: 'pie', radius: '55%', center: ['50%', '60%'], data: newValue, itemStyle: { emphasis: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' } } }] }; myChart.setOption(option); }, true); window.addEventListener(\"resize\", function() { //这里使用$window.onresize方法会使前面的图表无法调整大小 myChart.resize(); }); } };}); 参考ECharts - 可高度个性化定制的数据可视化图表ECharts - API在AngularJS中使用Echarts","link":"/2019/08/18/javascript/echarts/"},{"title":"node-sass 安装失败问题","text":"环境变量中设置SASS_BINARY_PATH路径 命令行中设置变量 1set SASS_BINARY_PATH=C:\\Users\\charles.kou\\AppData\\Roaming\\npm\\node_modules\\node-sass\\vendor\\win32-x64-57\\binding.node 查看已设置的变量： 1echo %SASS_BINARY_PATH%","link":"/2019/09/21/javascript/node-sass/"},{"title":"nrm切换registry","text":"nrm 是npm registry的管理工具，能够查看和切换当前使用的registryinstall: 1npm install -g nrm list: 1nrm ls test: 1nrm test use: 1nrm use [registryname] 常用：nrm use taobao","link":"/2019/08/18/javascript/nrm/"},{"title":"nvm-windows安装使用指南","text":"nvm-windows nvm-windows是一个命令行工具 nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系 nvm-windows切换node版本时，不同node版本之间不共享npm模块 安装nvm-windows前需要卸载及删除node npm相关文件 安装nvm-windows后必须为每个新安装的node单独安装全局应用，如gulp 安装前建议全局模块如当前已经安装node，且npm全局安装过一些模块，建议记录下这些全局模块留档命令如下： 1npm list -g --depth 0 项目模块如项目中node_modules中包含模块，建议保存一份存档；如确定项目中package.json里的dependencies和devDependencies配置是规范的，可略过此项 卸载node安装前先卸载任何现有版本的node.js, 并删除nodejs安装目录可通过以下命令查找node或npm的安装路径： 12where nodewhere npm 查看是否完整删除的检查项包括但不限于： 控制面板中卸载Node.js C:\\Program Files\\nodejs C:\\Users\\weiqinl\\AppData\\Roaming\\npm 删除环境变量中node npm相关项 如条件允许，建议重启（刷新电脑软件注册表） 下载nvm-windowshttps://github.com/coreybutler/nvm-windows/releases选择安装包方式, 对应文件：nvm-setup.zip 安装使用nvm-setup.zip中的exe文件进行安装安装注意事项： nvm的安装路径名称中最好不要有空格 nodejs安装目录建议保持默认，即C:\\Program Files\\nodejs 检查检查是否安装成功，命令： 1nvm 使用常用命令： 12345678910111213141516171819# 显示当前运行的nvm版本, 可简写为nvm vnvm version# 启用node.js版本管理nvm on# 禁用node.js版本管理(不卸载任何东西)nvm off# 设置node镜像nvm node_mirror https://npm.taobao.org/mirrors/node/# 设置npm镜像nvm npm_mirror https://npm.taobao.org/mirrors/npm/# 列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表# 命令可以简写为nvm ls [available]nvm list [available]# 安装nvm install &lt;version&gt;# 卸载nvm uninstall &lt;version&gt;# 切换到使用指定的nodejs版本nvm use [version] node版本LTS：长期支持（Long Term Support）Current：当前最新版本 Node.js 的版本命名规则遵循 semver语义化版本（Semantic Versioning），版本号分为三部分: 第一个数字（semver-major）增加，表示有不兼容的改变 第二个数字（semver-minor）增加，表示有保持兼容的新特性 第三个数字（semver-patch）增加，表示有在保持兼容性与特性不变的前提下的改动，比如修复了 bug 或者改进了文档 参考 nvm-windows - Github Windows上安装nodejs版本管理器nvm Node.js中文官网 Node.js中文网 - API 语义化版本 多版本node安装相关知识","link":"/2019/08/18/javascript/nvm-windows/"},{"title":"Mysql 查看binlog","text":"解压缩tar -xzvf binlog-free.tar.gz mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.02702* 这个命令是查看日志内容的mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.000001 mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0273* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0277* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0280* &gt;prd.sql mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0293* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0313* &gt;prd.sql linux 下执行替换文件名中的.sql为空字符串rename .sql.rm ‘’ * windows下添加后缀名ren * *.sql","link":"/2019/08/14/mysql/mysql-binlog/"},{"title":"Mysql常用函数","text":"1234567891011121314151617181920212223242526-- 求绝对值ABS(x)-- 四舍五入ROUND(x)-- 字符数CHAR_LENGTH(s)-- 字符串长度LENGTH(s)-- 字符串拼接CONCAT(s1,s2,...)-- 字符串截取：从字符串s中的第a个字符开始取b个字符SUBSTRING(s,a,b)-- 当前日期CURRENT_DATE()-- 当前时间CURRENT_TIME()-- 当前时间戳UNIX_TIMESTAMP()-- 把UNIX时间戳的时间转换为普通格式的时间FROM_UNIXTIME(d)-- 如果表达式expr成立，返回结果v1；否则，返回结果v2。IF(expr,v1,v2)-- 如果v1的不为空，就显示v1的值；否则就显示v2的值。IFNULL(v1,v2)-- 数据库版本号VERSION()","link":"/2019/08/14/mysql/mysql-function/"},{"title":"MySQL索引","text":"索引 基数：索引区分度，采样统计 数据页 变更触发索引统计 重新统计索引信息命令：analyze table t 优化器选择索引 扫描行数 explain强制使用索引 force index(a)设置慢查询SQL阈值 set long_query_time=0;全表扫描 前缀索引 字符串字段创建索引","link":"/2019/11/02/mysql/mysql-index/"},{"title":"Mysql Regexp 正则表达式","text":"123456-- 查找name字段中以'st'为开头的所有数据SELECT name FROM person_tbl WHERE name REGEXP '^st';-- 查找name字段中以'ok'为结尾的所有数据SELECT name FROM person_tbl WHERE name REGEXP 'ok$';-- 查找name字段中包含'mar'字符串的所有数据SELECT name FROM person_tbl WHERE name REGEXP 'mar'; 参考：https://www.runoob.com/mysql/mysql-regexp.html","link":"/2019/08/14/mysql/mysql-regexp/"},{"title":"使用Beyond Compare作为Git Bash文本差异对比冲突合并工具","text":"在Windows下安装Git命令行后，默认的文本比较工具一般是Git自己内置的diff实现，可以用更为通用方便的外部工具Beyond Compare工具来代替内置diff软件来进行文件比较及合并和解决冲突。 1. 卸载如安装过，记录当前版本号，例如：4.2.5.23088卸载后重启计算机 2. 安装下载地址：https://www.scootersoftware.com/download.php 建议切换与原有安装版本不同的大版本 安装时建议记录安装路径，如：C:\\Program Files\\Beyond Compare 从官网上下载的评估版本评估周期为30天 - 根据打开软件的时间累加，实际评估时间根据使用频率不同，可达2~3个月评估过期后，需要重新执行第1、2步 3. Git配置Git用户配置文件一般路径：C:\\Users\\username.gitconfig 修改内容添加以下配置节，注意修改Beyond Compare软件安装路径： 12345678910111213141516[diff] tool = bc4 algorithm = histogram[difftool] prompt = false[difftool &quot;bc4&quot;] cmd = \\&quot;c:/Program Files/Beyond Compare/BComp.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; [merge] tool = bc4[mergetool] prompt = false keepBackup = false[mergetool &quot;bc4&quot;] cmd = \\&quot;c:/Program Files/Beyond Compare/BComp.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; \\&quot;$BASE\\&quot; \\&quot;$MERGED\\&quot; trustExitCode = true 4. 使用比对当前文件相对于Head版本的改动： 1git difftool 解决冲突： 1git mergetool","link":"/2019/08/31/tools/beyondcompare/"},{"title":"Mysql相关","text":"函数1234567891011121314151617181920212223242526-- 求绝对值ABS(x)-- 四舍五入ROUND(x)-- 字符数CHAR_LENGTH(s)-- 字符串长度LENGTH(s)-- 字符串拼接CONCAT(s1,s2,...)-- 字符串截取：从字符串s中的第a个字符开始取b个字符SUBSTRING(s,a,b)-- 当前日期CURRENT_DATE()-- 当前时间CURRENT_TIME()-- 当前时间戳UNIX_TIMESTAMP()-- 把UNIX时间戳的时间转换为普通格式的时间FROM_UNIXTIME(d)-- 如果表达式expr成立，返回结果v1；否则，返回结果v2。IF(expr,v1,v2)-- 如果v1的不为空，就显示v1的值；否则就显示v2的值。IFNULL(v1,v2)-- 数据库版本号VERSION() 正则表达式123456-- 查找name字段中以'st'为开头的所有数据SELECT name FROM person_tbl WHERE name REGEXP '^st';-- 查找name字段中以'ok'为结尾的所有数据SELECT name FROM person_tbl WHERE name REGEXP 'ok$';-- 查找name字段中包含'mar'字符串的所有数据SELECT name FROM person_tbl WHERE name REGEXP 'mar'; 参考：https://www.runoob.com/mysql/mysql-regexp.html 查看数据库表结构表12345678SELECT t.TABLE_SCHEMA, t.TABLE_NAME, t.TABLE_TYPE, t.CREATE_TIME, t.TABLE_COMMENTFROM information_schema.`TABLES` t; 列1234567891011SELECT t.TABLE_SCHEMA, t.TABLE_NAME, t.COLUMN_NAME, t.ORDINAL_POSITION, t.COLUMN_DEFAULT, t.IS_NULLABLE, t.COLUMN_TYPE, t.COLUMN_COMMENTFROM information_schema.`COLUMNS` t; SQL优化todo 查看binlog解压缩tar -xzvf binlog-free.tar.gz mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.02702* 这个命令是查看日志内容的mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.000001 mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0273* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0277* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0280* &gt;prd.sql mysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0293* &gt;prd.sqlmysqlbinlog -vvv –base64-output=decode-rows mysql-bin.0313* &gt;prd.sql linux 下执行替换文件名中的.sql为空字符串rename .sql.rm ‘’ * windows下添加后缀名ren * *.sql docker安装mysql拉取镜像 1docker pull mysql:5.7 启动mysql容器 1234567docker run --name mysql \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD={root_password_word} \\ -v /var/lib/mysql:/var/lib/mysql \\ -v /etc/my.cnf:/etc/my.cnf \\ -v /etc/my.cnf.d:/etc/my.cnf.d \\ --restart=always -d mysql:5.7 进入运行中的mysql容器 1docker exec -it mysql -uroot -p123456","link":"/2019/08/14/mysql/mysql/"},{"title":"通用工具导航","text":"时间戳转换 http://tool.chinaz.com/Tools/unixtime.aspx BASE64编码解码 http://tool.oschina.net/encrypt?type=3 yaml转properties https://www.toyaml.com/index.html TTC转TTF https://transfonter.org/ttc-unpack 博客：https://www.cnkirito.moe/ 插件网站：https://github.com/ppoffice Online JSON Viewer：http://jsonviewer.stack.hu Cron表达式生成器：https://cron.qqe2.com/ PHP在线执行：https://tool.lu/coderunner/","link":"/2019/10/30/tools/common/"},{"title":"fiddler","text":"urlreplace路由拦截重定向eg： 12urlreplace 192.168.20.220/hub 192.168.21.110:8080/huburlreplace test.api.com localhost:8088 手机抓包参考：https://www.cnblogs.com/yyhh/p/5140852.html","link":"/2019/08/13/tools/fiddler/"},{"title":"elk","text":"组件语法使用双引号包起来作为一个短语搜索 “like Gecko”返回结果中需要有http字段 exists:http不能含有http字段 missing:http匹配单个字符 ?匹配0到多个字符 * 搜索结果中必须包含此项 +不能含有此项 -","link":"/2019/08/10/tools/elk/"},{"title":"Jira","text":"","link":"/2019/08/10/tools/jira/"},{"title":"linux","text":"command创建文件1touch test.sh 清空文件内容命令123echo \"\" &gt;log.log# &gt; 是重写，覆盖式# &gt;&gt;是尾部追加 查看历史命令12historyhistory | grep telnet 服务开机启动12systemctl enable docker.servicesystemctl start docker.service 查看进程123ps aux | grep php# 关闭ps aux | grep php | xargs kill -9 http12curl -H \"Content-type: application/json\" -X POST -d '{\"param1\":\"xxx\"}' http://test.api.com/postcurl --insecure -I -H \"Content-type: application/json\" -X DELETE http://test.api.com/delete/{id} 查看文件占用空间1du -h --max-depth=1","link":"/2019/08/14/tools/linux/"},{"title":"Grafana","text":"Time series return column named time or time_sec (in UTC), as a unix time stamp or any sql native date data type. You can use the macros below. return column(s) with numeric datatype as valuesOptional: return column named metric to represent the series name. If multiple value columns are returned the metric column is used as prefix. If no column named metric is found the column name of the value column is used as series nameResultsets of time series queries need to be sorted by time. 时间选择","link":"/2019/08/10/tools/grafana/"},{"title":"proxy","text":"代理反向代理","link":"/2019/08/14/tools/proxy/"},{"title":"markdown","text":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 标题123# 这是一级标题## 这是二级标题### 这是三级标题 引用12&gt;这是引用的内容&gt;&gt;这是引用的内容 分割线12---*** 图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 代码单行代码： 1`单行代码` 多行代码： 1234(```)多行代码多行代码(```) 前后三个反引号处加了小括号，实际是没有的。这里只是用来演示。 列表123- 列表内容 1. 列表嵌套 2. 嵌套","link":"/2019/08/10/tools/markdown/"},{"title":"redis","text":"Redis是一个开源的使用 ANSI C语言编写，支持网络，可基于内存也可持久化的日志型，Key-Value数据库，并提供了多种语言的 API ,相比 Memcached 它支持存储的类型相对更多 (字符，哈希，集合，有序集合，列表等)，同时Redis是线程安全的。 redis-cli安装命令1234redis-cli -h redis.test.net -a TlJ8JsgzWHMOcbBMUEIw info memoryredis-cli -h redis.test.net -a TlJ8JsgzWHMOcbBMUEIw keys \"*\"redis-cli -h redis.test.net -a TlJ8JsgzWHMOcbBMUEIw keys \"KEY:KEYNAME*\"redis-cli -h redis.test.net -a TlJ8JsgzWHMOcbBMUEIw keys \"KEY:KEYNAME*\" | xargs redis-cli -h redis.test.net -a TlJ8JsgzWHMOcbBMUEIw del Redis 客户端连接池客户端连接 Redis 使用的是 TCP协议，直连的方式每次需要建立 TCP连接，而连接池的方式是可以预先初始化好客户端连接，所以每次只需要从 连接池借用即可，而借用和归还操作是在本地进行的，只有少量的并发同步开销，远远小于新建TCP连接的开销。另外，直连的方式无法限制 redis客户端对象的个数，在极端情况下可能会造成连接泄漏，而连接池的形式可以有效的保护和控制资源的使用。客户端直连方式和连接池方式的对比：优点缺点直连优点：简单方便，适用于少量长期连接的场景缺点： 存在每次新建/关闭TCP连接开销 资源无法控制，极端情况下出现连接泄漏 Jedis对象线程不安全(Lettuce对象是线程安全的)连接池优点：无需每次连接生成Jedis对象，降低开销缺点：使用连接池的形式保护和控制资源的使用相对于直连，使用更加麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题 LettuceLettuce 是 一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection,它利用Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。springboot 2.x版本中默认客户端是用 lettuce实现的。 JedisJedis 在实现上是直连 redis server，多线程环境下非线程安全，除非使用连接池，为每个 redis实例增加 物理连接。在 springboot 1.5.x版本的默认的Redis客户端是 Jedis实现的。 参考：https://juejin.im/post/5ba0a098f265da0adb30c684","link":"/2019/08/14/tools/redis/"},{"title":"Rest接口批量调用","text":"shell脚本批量执行命令 #!/bin/bashecho “hello”echo “world” curl -H “Content-type: application/json” -X POST -d ‘{“param”: “test_user”}’ https://xxx:xx","link":"/2019/09/21/tools/rest/"},{"title":"sublime","text":"","link":"/2019/08/10/tools/sublime/"},{"title":"UPS Tracking API","text":"Request Url: JSON Request Sample: 12345678910111213141516{ &quot;UPSSecurity&quot;: { &quot;UsernameToken&quot;: { &quot;Username&quot;: &quot; userHere&quot;, &quot;Password&quot;: &quot; passHere&quot; } }, &quot;ServiceAccessToken&quot;: { &quot;AccessLicenseNumber&quot;: &quot;licNoHere&quot; }, &quot;Request&quot;: { &quot;RequestOption&quot;: &quot;15&quot; }, &quot;InquiryNumber&quot;: &quot;1Z12345E0291980793&quot;, &quot;TrackingOption&quot;: &quot;02&quot;}","link":"/2019/09/21/tools/ups/"},{"title":"vscode","text":"实时预览 Ctrl + Shift + P 调出主命令框，输入 Markdown，应该会匹配到几项 Markdown相关命令, 选择Markdown: Open Preview to the Side，就能调出实时预览框 先按Ctrl + K，然后放掉，紧接着再按 v，也能调出实时预览框 关闭预览模式单击文件名默认打开“预览模式”的Tab，单击其他文件时，会覆盖当前打开的文件。预览模式Tab的标志为Tab名称是斜体的。此逻辑同Sublime等各类编辑器，为默认功能。可关闭，关闭方式为：文件 -&gt; 首选项 -&gt; 设置，搜索’preview’, 关闭工作台 -&gt; 编辑管理中的设置 12Workbench &gt; Editor &gt; Enable PreviewWorkbench &gt; Editor &gt; Enable Preview From Quick Open","link":"/2019/08/10/tools/vscode/"},{"title":"vpn","text":"注册连接vpn后在管理员模式命令行执行以下命令进行注册 123REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Services\\PolicyAgent /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 0x2 /fREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Services\\RasMan\\Parameters /v ProhibitIpSec /t REG_DWORD /d 0x0 /fREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Services\\PolicyAgent /v AllowL2TPWeakCrypto /t REG_DWORD /d 0x1 /f","link":"/2019/08/13/tools/vpn/"},{"title":"kubernetes","text":"基本概念集群一个集群指容器运行所需要的云资源组合，关联了若干服务器节点、负载均衡、专有网络等云资源。 节点一台服务器（可以是虚拟机实例或者物理服务器）已经安装了 Docker Engine，可以用于部署和管理容器；容器服务的 Agent 程序会安装到节点上并注册到一个集群上。集群中的节点数量可以伸缩。 容器一个通过 Docker 镜像创建的运行时实例，一个节点可运行多个容器。 镜像Docker 镜像是容器应用打包的标准格式，在部署容器化应用时可以指定镜像，镜像可以来自于 Docker Hub，阿里云容器 Hub，或者用户的私有 Registry。镜像 ID 可以由镜像所在仓库 URI 和镜像 Tag（缺省为 latest）唯一确认。 编排模板编排模板包含了一组容器服务的定义和其相互关联，可以用于多容器应用的部署和管理。容器服务支持 Docker Compose 模板规范并有所扩展。 应用一个应用可通过单个镜像或一个编排模板创建，每个应用可包含1个或多个服务。 服务一组基于相同镜像和配置定义的容器，作为一个可伸缩的微服务。 关联关系 Kubernetes 相关概念Kubernetes是一个 Google 开源的，用于自动部署、扩展和管理容器化应用的大规模容器编排调度系统。具有可移植、可扩展和自动调度等特性。 节点（Node）Kubernetes 集群中的计算能力由 Node 提供，Kubernetes 集群中的 Node 是所有 Pod 运行所在的工作主机，可以是物理机也可以是虚拟机。工作主机的统一特征是上面要运行 kubelet 管理节点上运行的容器。命名空间（Namespace）命名空间为 Kubernetes 集群提供虚拟的隔离作用。Kubernetes 集群初始有 3 个命名空间，分别是默认命名空间 default、系统命名空间 kube-system 和 kube-public ，除此以外，管理员可以可以创建新的名字空间满足需要。 PodPod是 Kubernetes 部署应用或服务的最小的基本单位。一个Pod 封装多个应用容器（也可以只有一个容器）、存储资源、一个独立的网络 IP 以及管理控制容器运行方式的策略选项。副本控制器（Replication Controller，RC）RC 确保任何时候 Kubernetes 集群中有指定数量的 pod 副本(replicas)在运行。通过监控运行中的 Pod 来保证集群中运行指定数目的 Pod 副本。指定的数目可以是多个也可以是1个；少于指定数目，RC 就会启动运行新的 Pod 副本；多于指定数目，RC 就会终止多余的 Pod 副本。 副本集（Replica Set，RS）ReplicaSet（RS）是 RC 的升级版本，唯一区别是对选择器的支持，RS 能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为 Deployment 的理想状态参数使用。部署（Deployment）部署表示用户对 Kubernetes 集群的一次更新操作。部署比 RS 应用更广，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更通用的 Deployment 来描述。不建议您手动管理利用 Deployment 创建的 RS。 服务（Service）Service 也是 Kubernetes 的基本操作单元，是真实应用服务的抽象，每一个服务后面都有很多对应的容器来提供支持，通过 Kube-Proxy 的 port 和服务 selector 决定服务请求传递给后端的容器，对外表现为一个单一访问接口，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。 标签（labels）Labels 的实质是附着在资源对象上的一系列 Key/Value 键值对，用于指定对用户有意义的对象的属性，标签对内核系统是没有直接意义的。标签可以在创建一个对象的时候直接赋予，也可以在后期随时修改，每一个对象可以拥有多个标签，但 key 值必须唯一。 存储卷（Volume）Kubernetes 集群中的存储卷跟 Docker 的存储卷有些类似，只不过 Docker 的存储卷作用范围为一个容器，而 Kubernetes 的存储卷的生命周期和作用范围是一个 Pod。每个 Pod 中声明的存储卷由 Pod 中的所有容器共享。支持使用 Persistent Volume Claim 即 PVC 这种逻辑存储，使用者可以忽略后台的实际存储技术，具体关于 Persistent Volumn(pv)的配置由存储管理员来配置。持久存储卷（Persistent Volume，PV）和持久存储卷声明（Persistent Volume Claim，PVC）PV 和 PVC 使得 Kubernetes 集群具备了存储的逻辑抽象能力，使得在配置 Pod 的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给 PV 的配置者。存储的 PV 和 PVC 的这种关系，跟计算的 Node 和 Pod 的关系是非常类似的；PV 和 Node 是资源的提供者，根据集群的基础设施变化而变化，由 Kubernetes 集群管理员配置；而 PVC 和 Pod是资源的使用者，根据业务服务的需求变化而变化，由 Kubernetes 集群的使用者即服务的管理员来配置。 IngressIngress 是授权入站连接到达集群服务的规则集合。你可以通过 Ingress 配置提供外部可访问的 URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过 POST Ingress 资源到 API server 的方式来请求 ingress。 Ingress controller 负责实现 Ingress，通常使用负载均衡器，它还可以配置边界路由和其他前端，这有助于以 HA 方式处理流量。参考：https://www.alibabacloud.com/help/zh/doc-detail/25975.htm?spm=a2c63.p38356.b99.9.10c927a1mjblZa PodServiceService 的虚拟 IP 是有 Kubernetes 虚拟出来的内部网络，外部网络是无法访问的，但是有一些 Service 有需要对外暴露，比如 Web 前段。这时候就需要增加一层路由转发，即外网到内网的转发，Kubernetes 提供了 NodePort Service方式发布Service外部访问 - NodePort: 1234567891011121314apiVersion: v1kind: Servicemetadata: name: my-nginx-svc labels: app: nginxspec: type: NodePort ports: - port: 80 targetPort: 80 nodePort: 30010 selector: app: nginx DeploymentIngressNginxTraefikKubernetes Ingress 示例:路径转换rewrite： 1234567891011121314apiVersion: extensions/v1beta1kind: Ingressmetadata: name: wms annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - http: paths: - path: /wms backend: serviceName: wms servicePort: 8080 host域名映射： 123456789101112131415apiVersion: extensions/v1beta1kind: Ingressmetadata: name: config annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - host: config http: paths: - path: /config backend: serviceName: config servicePort: 8888 kubectl安装官网提供的安装命令是: curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectlGithub安装方式： 到这个页面选择当前的版本，点击进去https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#client-binaries-1 找到client binaries（也就是kubectl），选择对应操作系统的客户端，然后复制地址 下载kubectl包，解压后，将kubectl命令赋予权限和拷贝到用户命令目录下 12345wget https://dl.k8s.io/v1.9.3/kubernetes-client-linux-amd64.tar.gztar -zxvf kubernetes-client-linux-amd64.tar.gzcd kubernetes/client/binchmod +x ./kubectlsudo mv ./kubectl /usr/local/bin/kubectl 运行 kubectl version，返回版本信息，说明安装成功 常用命令12345678910111213141516171819kubectl get namespaceskubectl get nodeskubectl get pods -n kube-systemkubectl get rc -n kube-systemkubectl get rs -n kube-systemkubectl get deployment -n kube-systemkubectl get services -n kube-systemkubectl get secrets -n kube-systemkubectl get roles.rbac.authorization.k8s.io -n kube-systemkubectl get serviceaccounts -n kube-systemkubectl get rolebindings.rbac.authorization.k8s.io -n kube-systemkubectl get namespacekubectl get svc,deploy,pod,ingress -n ingress-nginxkubectl get cm -n ingress-nginxkubectl get svc -n ingress-nginx 发布 应用构建和发布流程说明。 用户向Gitlab提交代码，代码中必须包含Dockerfile 将代码提交到远程仓库 用户在发布应用时需要填写git仓库地址和分支、服务类型、服务名称、资源数量、实例个数，确定后触发Jenkins自动构建 Jenkins的CI流水线自动编译代码并打包成docker镜像推送到Harbor镜像仓库 Jenkins的CI流水线中包括了自定义脚本，根据我们已准备好的kubernetes的YAML模板，将其中的变量替换成用户输入的选项 生成应用的kubernetes YAML配置文件 更新Ingress的配置，根据新部署的应用的名称，在ingress的配置文件中增加一条路由信息 更新PowerDNS，向其中插入一条DNS记录，IP地址是边缘节点的IP地址。 Jenkins调用kubernetes的API，部署应用 滚动更新 如果通过滚动更新来更新部署服务，Kubernetes 会慢慢终止旧的 pod，同时加速生成新的 pod。为了最大程度减小对最终用户的影响，并尽可能缩短恢复时间，应用程序能够正常终止十分重要。 Kubernetes 决定终止 pod，将发生一系列事件。Kubernetes 终止生命周期的各个步骤如下： 将 pod 设置为“正在终止”状态，并将其从所有服务的端点列表中移除此时，pod 停止获取新流量，Pod 中运行的容器不受影响。 执行 preStop 钩子preStop 钩子是向 pod 中的容器发送的特殊命令或 http 请求。如果您的应用程序在收到 SIGTERM 后未正常关闭，可使用此钩子触发正常关闭。大多数程序在收到 SIGTERM 后都会正常关闭，但如果您使用的是第三方代码或管理的系统不受您控制，preStop 钩子将是一个不错的方案，可帮您在不修改应用程序的情况下触发正常关闭。 向 pod 发送 SIGTERM 信号此时，Kubernetes 将向 pod 中的容器发送 SIGTERM 信号。此信号通知容器它们即将被关闭。您的代码应侦听此事件，并在此时开始“干净地”关闭。这可能包括停止所有长时间连接（如数据库连接或 WebSocket 流）、保存当前状态或类似任务。即使您现在已经在使用 preStop 钩子，也有必要测试一下应用程序在您向它发送 SIGTERM 信号后的反应，以免在实际使用时对实际情况感到惊讶！ Kubernetes 等待片刻（宽限期）此时，Kubernetes 将等待片刻，此时间称为终止宽限期，具体值可指定。默认值为 30 秒。需要注意的是，这与 preStop 钩子和 SIGTERM 信号并行发生。Kubernetes 不会等待 preStop 钩子完成。如果您的应用在 terminationGracePeriod 完成之前完成关闭并退出，Kubernetes 将立即转到下一步。如果您的 pod 通常需要 30 秒以上的时间才能关闭，请务必延长宽限期。您可以通过在 Pod YAML 中设置 terminationGracePeriodSeconds 选项来实现此目的。例如，可将该值改为 60 秒： 向 pod 发送 SIGKILL 信号，pod 随即被移除如果宽限期结束后容器仍在运行，将向容器发送 SIGKILL 信号并强制将它们移除。此时，所有 Kubernetes 对象将被一同清理。 结论Kubernetes 可以出于各种原因终止 pod，确保您的应用程序正常执行这些终止操作是创建稳定系统和提供良好用户体验的核心。 蓝绿部署在进行蓝/绿部署时，应用程序的一个新副本（绿）将与现有版本（蓝）一起部署。然后更新应用程序的入口/路由器以切换到新版本（绿）。然后，您需要等待旧（蓝）版本来完成所有发送给它的请求，但是大多数情况下，应用程序的流量将一次更改为新版本。 无缝发布 滚动发布 金丝雀发布 灰度发布Canary 金丝雀发布: 准备和生产环境隔离的“金丝雀”服务器。 将新版本的服务部署到“金丝雀”服务器上。 对“金丝雀”服务器上的服务进行自动化和人工测试。 测试通过后，将“金丝雀”服务器连接到生产环境，将少量生产流量导入到“金丝雀”服务器中。 如果在线测试出现问题，则通过把生产流量从“金丝雀”服务器中重新路由到老版本的服务的方式进行回退，修复问题后重新进行发布。 如果在线测试顺利，则逐渐把生产流量按一定策略逐渐导入到新版本服务器中。 待新版本服务稳定运行后，删除老版本服务。 参考：https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&amp;mid=2247489100&amp;idx=1&amp;sn=eab291eb345c074114d946b732e037eb&amp;source=41#wechat_redirect Liveness和Readiness探针kubelet 使用 liveness probe（存活探针）来确定何时重启容器。例如，当应用程序处于运行状态但无法做进一步操作，liveness 探针将捕获到 deadlock，重启处于该状态下的容器，使应用程序在存在 bug 的情况下依然能够继续运行下去。Kubelet 使用 readiness probe（就绪探针）来确定容器是否已经就绪可以接受流量。只有当 Pod 中的容器都处于就绪状态时 kubelet 才会认定该 Pod处于就绪状态。该信号的作用是控制哪些 Pod应该作为service的后端。如果 Pod 处于非就绪状态，那么它们将会被从 service 的 load balancer中移除。 配置 ProbeProbe 中有很多精确和详细的配置，通过它们您能准确的控制 liveness 和 readiness 检查： initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒。 periodSeconds：执行探测的频率。默认是10秒，最小1秒。 timeoutSeconds：探测超时时间。默认1秒，最小1秒。 successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是 1。对于 liveness 必须是 1。最小值是 1。 failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是 3。最小值是 1。HTTP probe 中可以给 httpGet设置其他配置项： host：连接的主机名，默认连接到 pod 的 IP。您可能想在 http header 中设置 “Host” 而不是使用 IP。 scheme：连接使用的 schema，默认HTTP。 path: 访问的HTTP server 的 path。 httpHeaders：自定义请求的 header。HTTP运行重复的 header。 port：访问的容器的端口名字或者端口号。端口号必须介于 1 和 65525 之间。对于 HTTP 探测器，kubelet 向指定的路径和端口发送 HTTP 请求以执行检查。 Kubelet 将 probe 发送到容器的 IP 地址，除非地址被httpGet中的可选host字段覆盖。 在大多数情况下，您不想设置主机字段。 有一种情况下您可以设置它。 假设容器在127.0.0.1上侦听，并且 Pod 的hostNetwork字段为 true。 然后，在httpGet下的host应该设置为127.0.0.1。 如果您的 pod 依赖于虚拟主机，这可能是更常见的情况，您不应该是用host，而是应该在httpHeaders中设置Host头。 What’s next","link":"/2019/08/14/java/kubernetes/"}],"tags":[{"name":"Docker","slug":"docker","link":"/tags/docker/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Android","slug":"android","link":"/tags/android/"},{"name":"Java","slug":"java","link":"/tags/java/"},{"name":"Kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"TODO","slug":"todo","link":"/tags/todo/"},{"name":"Tool","slug":"tool","link":"/tags/tool/"},{"name":"MySQL","slug":"mysql","link":"/tags/mysql/"},{"name":"Spring Cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"Javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Angular","slug":"angular","link":"/tags/angular/"},{"name":"Node","slug":"node","link":"/tags/node/"},{"name":"Node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"Git","slug":"git","link":"/tags/git/"},{"name":"Spring Boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"Architecture","slug":"architecture","link":"/tags/architecture/"},{"name":"Kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"}],"categories":[]}